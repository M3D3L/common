import{u as j}from"./Ag6tYbTR.js";const A=3600*1e3,I="app-cache",y="cache-db",i="cache-store",U=({ttl:u=A,namespace:D=I,debug:g=!1}={})=>{const h=new Map;let m=!1;const $=`${D}|`;return(async()=>{if(!(typeof window>"u"||m))try{const e=indexedDB.open(y,1);e.onupgradeneeded=p=>{const w=e.result;w.objectStoreNames.contains(i)||w.createObjectStore(i,{keyPath:"key"})};const o=(await new Promise((p,w)=>{e.onsuccess=()=>p(e.result),e.onerror=()=>w(e.error)})).transaction(i,"readonly").objectStore(i).getAll();await new Promise(p=>{o.onsuccess=()=>{const w=o.result,x=Date.now();w.forEach(f=>{f.expiry>x&&h.set(f.key,{value:f.value,expiry:f.expiry})}),p()},o.onerror=()=>p()}),m=!0}catch(e){g&&console.error("IndexedDB initialization failed",e)}})().catch(()=>{}),{getCacheKey:(e,r={})=>{const s=Object.entries(r).sort(([a],[o])=>a.localeCompare(o)).map(([a,o])=>`${a}:${JSON.stringify(o)}`).join("|");return`${$}${e}|${s}`},set:(e,r,s)=>{const a=Date.now()+(s??u),o={value:r,expiry:a};h.set(e,o),typeof window<"u"&&(indexedDB.open(y).onsuccess=p=>{const f=p.target.result.transaction(i,"readwrite").objectStore(i);f.put({key:e,...o}).onerror=()=>{g&&console.error("Failed to persist cache entry")}})},get:e=>{const r=h.get(e);return r?r.expiry<Date.now()?(h.delete(e),typeof window<"u"&&(indexedDB.open(y).onsuccess=s=>{s.target.result.transaction(i,"readwrite").objectStore(i).delete(e)}),null):r.value:null},del:e=>{h.delete(e),typeof window<"u"&&(indexedDB.open(y).onsuccess=r=>{r.target.result.transaction(i,"readwrite").objectStore(i).delete(e)})},clearExpired:()=>{const e=Date.now();h.forEach((r,s)=>{r.expiry<=e&&h.delete(s)})},clearAll:()=>{h.clear(),typeof window<"u"&&(indexedDB.open(y).onsuccess=e=>{e.target.result.transaction(i,"readwrite").objectStore(i).clear()})}}},E=U({ttl:60*60*1e3,namespace:"pb",debug:!1}),b=E.getCacheKey,C=E.set,F=E.get;function N(){const u=j();return{fetchCollection:async(t,n=1,c=10,d="",l="-created",e=null,r=null)=>{const s=b("fetchCollection",{collection:t,page:n,perPage:c,filter:d,sort:l,expand:e,fields:r}),a=F(s);if(a)return a;try{const o=await u.collection(t).getList(n,c,{filter:d,sort:l,expand:e??void 0,fields:r==null?void 0:r.join(",")});return C(s,o),o}catch(o){throw console.error(`Error fetching ${t}:`,o),new Error(`Failed to fetch ${t}`)}},fetchRecord:async(t,n)=>{const c=n.toString(),d=b("fetchRecord",{collection:t,id:c}),l=F(d);if(l)return l;try{const e=await u.collection(t).getOne(c);return C(d,e),e}catch(e){throw console.error(`Error fetching ${t} record ${c}:`,e),new Error(`Failed to fetch ${t} record`)}},createItem:async(t,n)=>{try{return await u.collection(t).create(n)}catch(c){throw console.error(`Error creating item in ${t}:`,c),new Error(`Failed to create item in ${t}`)}},updateItem:async(t,n,c)=>{try{return await u.collection(t).update(n,c)}catch(d){throw console.error(`Error updating item in ${t}:`,d),new Error(`Failed to update item in ${t}`)}},deleteItem:async(t,n)=>{try{return await u.collection(t).delete(n),!0}catch(c){throw console.error(`Error deleting item from ${t}:`,c),new Error(`Failed to delete item from ${t}`)}},uploadFile:async(t,n,c,d)=>{try{const l=new FormData;l.append(d,t);const e=await u.collection(n).update(c,l);return u.files.getUrl(e,e[d])}catch(l){throw console.error("Error uploading file:",l),new Error("Failed to upload file")}},getFileUrl:(t,n)=>u.files.getUrl(t,n),getCacheKey:b}}export{U as a,N as u};
